# 計算方法リスト

## <strong>総資産回転率</strong>

```text
資産をどれだけ有効に活用して売上を上げているかを表す財務指標で、
以下の式で算出される。

　売上高÷総資産
```

<br>

## <strong>総資産営業利益率(ROA)</strong>

```text
保有する資産に対してどれだけの利益を上げているかを表す財務指標で、
以下の式で算出される。

　営業利益÷総資産
```

<br>

## <strong>売上高営業利益率</strong>

```text
売上高に対してどれだけの利益を上げているかを表す財務指標で、
以下の式で算出される。

　営業利益÷売上高
```

<br>

## <strong>営業利益</strong>

```text
[ 売上高 ] －[ 売上原価 ]－[ 販売費・一般管理費 ]
[ 売上総利益 ] - [ 固定費 ]
```

<br>

## <strong>ホストコンピューターの処理時間</strong>

```text
（毎秒当たりの送信量 - 処理時間）× 右辺との差分 =
（毎秒当たりの送信量 - 処理時間）
```

<br>

## <strong>2 段階エディット法</strong>

```text
共通バグの発見率から全体の総エラー数を推定する手法


総エラー数のうちグループA，Bのバグ検出確率"P(A)"，"P(B)"は、

　P(A)＝NA／N　…(1)
　P(B)＝NB／N　…(2)

と定義することができ、そこからP(A)，P(B)が共に発生する"P(AB)"を、

　P(AB)＝　P(A)×P(B)＝NAB／N　…(3)

と導くことができます。

NAの検出率＝NA／N
NBの検出率＝NB／N
NABの検出率＝NAB／N

(3)の式に(1)と(2)を代入すると、

　(NA／N)×(NB／N)＝NAB／N

→　N＝NA×NB／NAB
```

<br>

## <strong>ページイン方式の割合の求め方</strong>

```text
ページインだけの処理の割合を"P"とすると、ページアウトを伴う処理の割合は
"1－P"で表すことができます。

それぞれの処理時間と平均処理時間の関係を表す次の式を解くと
　
　(ページアウトを伴わない場合のページインの処理時間) = 20ミリ秒
　(ページアウトを伴う場合，置換えページの選択，ページアウト，
　ページインの合計処理時間) = 60ミリ秒
　(1回のページフォールトの平均処理時間) = 30ミリ秒


　20×P＋30×(1－P)＝30
　20P＋60－60P＝30
　－40P＝－30
　P＝0.75
```

<br>

## <strong>損益分岐点売上高</strong>

```text
損益分岐点売上高＝固定費／(1－変動費率)
　　　　　　　　＝固定費÷｛（売上高−変動費）÷売上高｝
変動費率＝変動費／売上高

※
損益分岐点売上高：係る費用を収益でカバーでき、損益が「0」になって
                 これ以降は利益が出る、という売上高
変動費：原材料費、仕入原価、外注費、販売手数料など
固定費：人件費、地代家賃、リース料、広告宣伝費など
```

<br>

## <strong>10 進数の値を 26 進数に直す</strong>

```text
10進数の値＝ 123

10進数123を26で割ると、商と余りは以下のようになります。

　123÷26＝4余り19

英字と数字は対応しているため、各桁を4→E，19→Tと置き換えると26進数
「ET」になります。
```

<br>

## <strong>稼働率</strong>

```text
MTBF／(MTBF＋MTTR)
```

<br>

## <strong>B+木インデックスを格納するノードへのアクセス回数のオーダを表す式</strong>

```text
B+木インデックスでは探索範囲を1／nに狭めながら検索していきますが、
B+木の深さはどの葉でも一定であるため、どの値を探索する場合でもほぼ同じ
アクセス回数になります。この深さは各節点が持つエントリ数(次数)で決まり、
深さがh 、次数がbであるB+木における葉の最大数(X)は次の式で表せます。

　bh＝X (上の例でいえば33＝27)

つまりX件のデータを探索する際のアクセス回数を示す深さhは、

　h＝logbX

このため、アクセス回数のオーダはXの対数「O(logX)」になります。
```

![B+木インデックス](img/B%2B%E6%9C%A8%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9.gif)

<br>

## <strong>パイプライン制御</strong>

```text
CPU処理を高速化させるため、1命令を、命令読出し(フェッチ)、解読(デコード)、
アドレス計算、オペランド呼出し、実行 というような複数のステージに分け、
各ステージを少しずつずらしながら独立した処理機構で並列に実行することで、
処理時間全体を短縮させる技法です。
またパイプラインの処理時間を求める公式「(I＋D－1)×P」を用いても計算することができます。

命令数(I)が20、深さ(D)が5、ピッチは1サイクルなので、

　(20＋5－1)×1＝24サイクル
```

![パイプライン制御](img/%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3%E5%88%B6%E5%BE%A1.gif)

<br>

## <strong>ページフォールト</strong>

```text
ページング方式において要求されたページが主記憶上に存在しないときに発生する割込みです。
ページアウト／ページインの処理は、ページフォールトの発生を契機にして行われます。

[ページ0]
0は主記憶上にないためページフォールトが発生し、0がページインします。
0--

[ページ1]
1は主記憶上にないためページフォールトが発生し、1がページインします。
01-

[ページ2]
2は主記憶上にないためページフォールトが発生し、2がページインします。
012

[ページ3]
3は主記憶上にないためページフォールトが発生します。最終参照時刻が最も古いページ0がページアウトし、3がその位置にページインします。
312

[ページ4]
4は主記憶上にないためページフォールトが発生します。最終参照時刻が最も古いページ1がページアウトし、4がその位置にページインします。
342

[ページ0]
0は主記憶上にないためページフォールトが発生します。最終参照時刻が最も古いページ2がページアウトし、0がその位置にページインします。
340

[ページ2]
2は主記憶上にないためページフォールトが発生します。最終参照時刻が最も古いページ3がページアウトし、2がその位置にページインします。
240

[ページ4]
4は主記憶上にあるためページフォールトは発生しません。
240

[ページ3]
3は主記憶上にないためページフォールトが発生します。最終参照時刻が最も古いページ0がページアウトし、3がその位置にページインします。
243

[ページ1]
1は主記憶上にないためページフォールトが発生します。最終参照時刻が最も古いページ2がページアウトし、1がその位置にページインします。
143

[ページ4]
4は主記憶上にあるためページフォールトは発生しません。
143

[ページ5]
5は主記憶上にないためページフォールトが発生します。最終参照時刻が最も古いページ3がページアウトし、5がその位置にページインします。
145

したがって12回のページ読込み中ページフォールトが発生するのは「10回」です。
```

![ページフォールト](img/%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%95%E3%82%A9%E3%83%BC%E3%83%AB%E3%83%88.gif)

<br>

## <strong></strong>

```text

```
